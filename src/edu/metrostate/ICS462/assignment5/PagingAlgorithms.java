package edu.metrostate.ICS462.assignment5;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Deque;
import java.util.Iterator;
import java.util.Random;

/****************************************************************************************************************
* ICS 462 SUMMER 2019</br>
* Programming Assignment 5</br>
* Shannon Fisher</br>
* 06/21/2019</br>
* <p>
* 
* Website Citations...</br>
* Optimal algorithm reference:</br>
* https://www.thecrazyprogrammer.com/2016/11/optimal-page-replacement-algorithm-c.html
* <p>
* 
* Modulus for keeping track of cursor index:</br>
* https://en.wikipedia.org/wiki/Circular_buffer
* <p>
* 
* This program demonstrates the following page-replacement algorithms:
* <p>
* 
* <CODE>First-In-First-Out (FIFO)</CODE></br>
* <CODE>Least Recently Used (LRU)</CODE></br>
* <CODE>Optimal (OPT)</CODE></br>
****************************************************************************************************************/
public class PagingAlgorithms {

 	private static final String OUTPUT_FILENAME = "Fisher_Shannon_ProgAssign5.txt";
	private static final int RANDOM_PAGE_REF_STRING_SIZE = 20;
	
	private static int[] randomPageReference = new int[RANDOM_PAGE_REF_STRING_SIZE];
	private static int[] secondPageReference = { 0, 7, 1, 1, 2, 0, 8, 9, 0, 3, 0, 4, 5, 6, 7, 0, 8, 9, 1, 2 };
	private static int[] thirdPageReference = { 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1 };

 	private static StringBuilder stringBuilder = new StringBuilder();
 	
	/************************************************************************************************************
	 * Constructor to create a new PagingAlgorithms object to illustrate several page-replacement algorithms.
	 * <p>
	 * 
	 * @postcondition
	 *   A new PagingAlgorithms object has been created.
	 */
 	public PagingAlgorithms() {
 		
 		initialize();
	}

 	// **********************************************************************************************************
	// Private helper method for initialization.
	// 
	private void initialize() {
		
 		Random random = new Random();

 		{
			// Set the output file header information.
			stringBuilder.append("Shannon Fisher" + "\r\n");
			stringBuilder.append("ICS 462 Programming Assignment 5" + "\r\n" + "\r\n");
		}

 		// Build the random page reference string.
		for (int i = 0; i < RANDOM_PAGE_REF_STRING_SIZE; i++) {

			// Assigne a random number bewtween 0 and 9.
 			randomPageReference[i] = random.nextInt(10);
		}
	}
	
	/************************************************************************************************************
	 * This method illustrates the First-In-First-Out (FIFO) page-replacement algorithm.
	 * <p>
	 * 
	 * @param referenceString
	 *   the specified page-reference string this algorithm will process
	 * 
	 * @param frameSize
	 *   the maximum frame capacity that this algorithm is allowed to use
	 * 
	 * @return
	 *   The number of page faults generated by this algorithm.
	 */
 	public int firstInFirstOut(int[] referenceString, int frameSize) {

 		int faultCount = 0;
		int nextIndex = 0;
		int[] queue = new int[frameSize];
		
		// Start by iterating over the page-reference string.
 		for (int i = 0; i < referenceString.length; i++) {
 			
 			boolean matchFound = false;
			int pageValue = referenceString[i];

			// Iterate over the queue.
 			for (int k = 0; k < queue.length; k++) {

 				int queueValue = queue[k];
 				
 				// Set flag default to false; assume we do not have any match so far.
 				matchFound = false;
 				
 				if (queueValue == pageValue) {
 					
 					// Set flag to true for future processing; we've found a matching value.
 					matchFound = true;
					break;
				}
			}
 			
 			// If no matching page-reference exists between the queue and the reference string,
 			// add the page into the queue at the appropriate index and then advance that index
 			// in a way that maintains the properties of a circular buffer.
 			if (!matchFound) {

 				queue[nextIndex] = referenceString[i];
				nextIndex = Math.floorMod((nextIndex + 1), queue.length);
				faultCount++;
			}
		}
 		
 		return faultCount;
	}
 	
	/************************************************************************************************************
	 * This method illustrates the Least-Recently-Used (LRU) page-replacement algorithm.
	 * <p>
	 * 
	 * @param referenceString
	 *   the specified page-reference string this algorithm will process
	 * 
	 * @param frameSize
	 *   the maximum frame capacity that this algorithm is allowed to use
 	 * 
 	 * @return
	 *   The number of page faults generated by this algorithm.
 	 */
 	public int leastRecentlyUsed(int[] referenceString, int frameSize) {
 		
 		Deque<Integer> deque = new ArrayDeque<Integer>();
 		Integer found = null;
 		int faultCount = 0;
 		
		for (int k = 0; k < referenceString.length; k++) {
			
			int pageValue = referenceString[k];
			
			if (deque.contains(pageValue)) {
				
				Iterator<Integer> it = deque.iterator();
				
				while (it.hasNext()) {
					
					Integer nextItem = it.next();
					
					if (nextItem == pageValue) {
						
						found = nextItem;
						break;
					}
				}
				
				if (deque.remove(found)) {
					
					deque.addFirst(found);
				}
			}
			
			else if (deque.size() < frameSize) {
				
				deque.addFirst(pageValue);
				faultCount++;
			}
			
			else {
				
				deque.pollLast();
				deque.addFirst(pageValue);
				faultCount++;
			}
		}
 		
 		return faultCount;
	}
 	
	/************************************************************************************************************
	 * This method illustrates the Optimal (OPT) page-replacement algorithm.
	 * <p>
	 * 
	 * @param referenceString
	 *   the specified page-reference string this algorithm will process
	 * 
	 * @param frameSize
	 *   the maximum frame capacity that this algorithm is allowed to use
	 * 
 	 * @return
	 *   The number of page faults generated by this algorithm.
 	 */
	public int optimal(int[] referenceString, int frameSize) {

 		int faultCount = 0;
		int nextIndex = 0;
		int[] queue = new int[frameSize];
		
		// Fill the queue with sentinel values to indicate vacancies.
 		Arrays.fill(queue, -1);
 		
 		// Start by iterating over the page-reference string.
 		for (int i = 0; i < referenceString.length; i++) {

 			boolean matchFound = false;
			boolean vacant = false;
			int pageValue = referenceString[i];

 			for (int k = 0; k < queue.length; k++) {

 				int queueValue = queue[k];

 				matchFound = false;
				vacant = false;

 				if (queueValue == pageValue) {

 					matchFound = true;
					break;
				}

 				if (queueValue == -1) {

 					vacant = true;
				}
			}
 			
 			// Next, we need to check if there are any vacancies in the data structure.
 			// If so, this code will add the page into the queue at the appropriate index and then
 			// advance that index in a way that maintains the properties of a circular buffer.
 			if (vacant) {

 				queue[nextIndex] = referenceString[i];
				nextIndex = Math.floorMod((nextIndex + 1), queue.length);
				faultCount++;
				continue;
			}

 			if (!matchFound && !vacant) {
 				
 				int maxDistance = -1;
				int targetIndex = -1;

 				for (int queueIndex = 0; queueIndex < queue.length; queueIndex++) {
 					
 					int qValue = queue[queueIndex];
					int size = referenceString.length;
					int threshold = size - i;

 					for (int offsetIndex = i + 1; offsetIndex < size; offsetIndex++) {

 						int nextRefVal = referenceString[offsetIndex];

 						if (qValue == nextRefVal) {

 							if (offsetIndex - i > maxDistance) {

 								maxDistance = offsetIndex - i;
								targetIndex = queueIndex;
								break;
							}

 							else {

 								break;
							}
						}

 						else if (--threshold == 1) {

 							maxDistance = referenceString.length;
							targetIndex = queueIndex;
						}
					}
				}

 				if (targetIndex == -1) {

 					queue[nextIndex] = referenceString[i];
					nextIndex = Math.floorMod((nextIndex + 1), queue.length);
				}

 				else {

 					queue[targetIndex] = referenceString[i];
				}
 				
 				faultCount++;
			}
		}
 		
 		return faultCount;
	}

 	/************************************************************************************************************
	 * Method to write the program results to a file on local storage.
	 * <p>
	 * 
	 * @postcondition
	 *   The results of the paging algorithm operations.
	 * 
	 * @throws IOException
	 *   IOException is thrown if there is an I/O problem with the results file output.
	 */
	public void writeToFile() throws IOException {

 		// File printing and output setup.
		File file = new File(OUTPUT_FILENAME);
		FileWriter fileWriter = new FileWriter(file, true);
		PrintWriter printWriter = null;

 		try {

 			if (!file.exists()) {

 				file.createNewFile();
			}

 			printWriter = new PrintWriter(fileWriter);

 			// Print the contents of the results to the output file.
			printWriter.println(stringBuilder.toString());
		}

 		catch (IOException ex) {

 			ex.printStackTrace();
		}

 		finally {

 			printWriter.close();
		}
	}
	
	/************************************************************************************************************
	 * Main method from where program execution begins.
	 * <p>
	 * 
	 * @param args
	 *   this parameter is not used
	 * 
	 * @postcondition
	 *   The following three page-replacement algorithms have operated on three distinct sets of page-reference
	 *   strings, and the results have been output to a text file on local storage:
	 * <p>
	 * 
	 * <CODE>First-In-First-Out (FIFO)</CODE></br>
	 * <CODE>Least-Recently-Used (LRU)</CODE></br>
	 * <CODE>Optimal (OPT)</CODE></br>
	 * 
	 * @throws InterruptedException
	 *   InterruptedException is thrown if a thread is interrupted before or during its activity.
	 * 
	 * @throws IOException
	 *   IOException is thrown if there is an I/O problem with the results file output.
	 */
 	public static void main(String[] args) throws InterruptedException, IOException {

 		PagingAlgorithms application = new PagingAlgorithms();

 		// Create an array of page-reference string arrays.
 		int[][] pageReferenceList = { randomPageReference, secondPageReference, thirdPageReference };

 		// Iterate over the list of page-reference string arrays for processing.
 		for (int i = 0; i < pageReferenceList.length; i++) {
 			
 			// Process each page-reference string from 1 page frame up to 7 page frames.
 			for (int pageFrames = 1; pageFrames <= 7; pageFrames++) {
 				
 				int fifoFaults;
				int lruFaults;
				int optimalFaults;
				
				int[] currentReferenceString = pageReferenceList[i];

 				fifoFaults = application.firstInFirstOut(currentReferenceString, pageFrames);
 				lruFaults =application.leastRecentlyUsed(currentReferenceString, pageFrames);
				optimalFaults = application.optimal(currentReferenceString, pageFrames);
				
				stringBuilder.append("For " + pageFrames + " page frames, and using string page reference string: " + Arrays.toString(currentReferenceString) + "\r\n");
				stringBuilder.append("\r\n");
				stringBuilder.append("    FIFO had " + fifoFaults + " page faults.\r\n");
				//stringBuilder.append("     LRU had " + lruFaults + " page faults.\r\n");
				//stringBuilder.append("     OPT had " + optimalFaults + " page faults.\r\n");
				stringBuilder.append("\r\n");
			}
 			
 			stringBuilder.append("========================================================================================================================\r\n");
		}
 		
 		application.writeToFile();
	}
}
