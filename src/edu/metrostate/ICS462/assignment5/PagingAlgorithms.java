package edu.metrostate.ICS462.assignment5;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Deque;
import java.util.Iterator;
import java.util.Random;

/****************************************************************************************************************
* ICS 462 SUMMER 2019</br>
* Programming Assignment 5</br>
* Shannon Fisher</br>
* 06/21/2019</br>
* <p>
* 
* Website Citations...</br>
* Optimal algorithm reference:</br>
* https://www.thecrazyprogrammer.com/2016/11/optimal-page-replacement-algorithm-c.html
* <p>
* 
* Modulus for keeping track of cursor index:</br>
* https://en.wikipedia.org/wiki/Circular_buffer
* <p>
* 
* This program demonstrates the following page-replacement algorithms:
* <p>
* 
* <CODE>First-In-First-Out (FIFO)</CODE></br>
* <CODE>Least Recently Used (LRU)</CODE></br>
* <CODE>Optimal (OPT)</CODE></br>
****************************************************************************************************************/
public class PagingAlgorithms {

 	private static final String OUTPUT_FILENAME = "Fisher_Shannon_ProgAssign5.txt";
	private static final int RANDOM_PAGE_REF_STRING_SIZE = 20;
	
	private static int[] randomPageReference = new int[RANDOM_PAGE_REF_STRING_SIZE];
	private static int[] secondPageReference = { 0, 7, 1, 1, 2, 0, 8, 9, 0, 3, 0, 4, 5, 6, 7, 0, 8, 9, 1, 2 };
	private static int[] thirdPageReference = { 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1 };

 	private static StringBuilder stringBuilder = new StringBuilder();
 	
	/************************************************************************************************************
	 * Constructor to create a new PagingAlgorithms object to illustrate several page-replacement algorithms.
	 * <p>
	 * 
	 * @postcondition
	 *   A new PagingAlgorithms object has been created.
	 */
 	public PagingAlgorithms() {
 		
 		initialize();
	}

 	// **********************************************************************************************************
	// Private helper method for initialization.
	// 
	private void initialize() {
		
 		Random random = new Random();

 		{
			// Set the output file header information.
			stringBuilder.append("Shannon Fisher" + "\r\n");
			stringBuilder.append("ICS 462 Programming Assignment 5" + "\r\n" + "\r\n");
		}

 		// Build the random page reference string.
		for (int i = 0; i < RANDOM_PAGE_REF_STRING_SIZE; i++) {

			// Assigne a random number bewtween 0 and 9.
 			randomPageReference[i] = random.nextInt(10);
		}
	}
	
	/************************************************************************************************************
	 * This method illustrates the First-In-First-Out (FIFO) page-replacement algorithm.
	 * <p>
	 * 
	 * @param referenceString
	 *   the specified page-reference string this algorithm will process
	 * 
	 * @param frameSize
	 *   the maximum frame capacity that this algorithm is allowed to use
	 * 
	 * @return
	 *   The number of page faults generated by this algorithm.
	 */
 	public int firstInFirstOut(int[] referenceString, int frameSize) {

 		int faultCount = 0;
		int nextIndex = 0;
		int[] queue = new int[frameSize];
		
		// Fill the queue with sentinel values to indicate vacancies.
 		Arrays.fill(queue, -1);
		
		// Start by iterating over the page-reference string.
 		for (int i = 0; i < referenceString.length; i++) {
 			
 			boolean matchFound = false;
			int pageValue = referenceString[i];

			// Iterate over the queue.
 			for (int k = 0; k < queue.length; k++) {

 				int queueValue = queue[k];
 				
 				// Set flag default to false; assume we do not have any match so far.
 				matchFound = false;
 				
 				if (queueValue == pageValue) {
 					
 					// Set flag to true for future processing; we've found a matching value.
 					matchFound = true;
					break;
				}
			}
 			
 			// If no matching page-reference exists between the queue and the reference string,
 			// add the page into the queue at the appropriate index and then advance that index
 			// in a way that maintains the properties of a circular buffer.
 			if (!matchFound) {

 				queue[nextIndex] = referenceString[i];
				nextIndex = Math.floorMod((nextIndex + 1), queue.length);
				faultCount++;
			}
		}
 		
 		return faultCount;
	}
 	
	/************************************************************************************************************
	 * This method illustrates the Least-Recently-Used (LRU) page-replacement algorithm.
	 * <p>
	 * 
	 * @param referenceString
	 *   the specified page-reference string this algorithm will process
	 * 
	 * @param frameSize
	 *   the maximum frame capacity that this algorithm is allowed to use
 	 * 
 	 * @return
	 *   The number of page faults generated by this algorithm.
 	 */
 	public int leastRecentlyUsed(int[] referenceString, int frameSize) {
 		
 		// Java's Deque interface is well-suited for this algorithm by providing a few
 		// convenient methods to easily keep track of element additions and removals.
 		Deque<Integer> deque = new ArrayDeque<Integer>();
 		
 		// The 'found' variable will be used as a reference in a matching scenario.
 		Integer found = null;
 		int faultCount = 0;
 		
 		// Start by iterating over the page-reference string.
		for (int k = 0; k < referenceString.length; k++) {
			
			int pageValue = referenceString[k];
			
			// Check if the deque contains the proposed value.
			if (deque.contains(pageValue)) {
				
				Iterator<Integer> it = deque.iterator();
				
				// If the deque contains the proposed value, iterate over the deque.
				while (it.hasNext()) {
					
					Integer nextItem = it.next();
					
					// Find the next item in the collection that matches the proposed value.
					if (nextItem == pageValue) {
						
						// Store a reference to the matching item, then break because there
						// will never be two items of the same value in the deque so there is
						// no need to look any further in the collection.
						found = nextItem;
						break;
					}
				}
				
				// Remove the matching item from the deque, regardless of where it is located.
				if (deque.remove(found)) {
					
					// Add the matching item back to the front of the deque ('top' of the stack);
					deque.addFirst(found);
				}
			}
			
			// If the deque does not contain the proposed value, check to see if we still have
			// enough capacity to add to the deque without shifting any other elements around.
			else if (deque.size() < frameSize) {
				
				// Add to the front of the deque.
				deque.addFirst(pageValue);
				faultCount++;
			}
			
			// If the proposed value is not found in the deque, and if there is no more room to
			// add to the deque, the we remove the 'last' element in the deque and then add the
			// page value to the front of the deque.
			else {
				
				deque.pollLast();
				deque.addFirst(pageValue);
				faultCount++;
			}
		}
 		
 		return faultCount;
	}
 	
	/************************************************************************************************************
	 * This method illustrates the Optimal (OPT) page-replacement algorithm.
	 * <p>
	 * 
	 * @param referenceString
	 *   the specified page-reference string this algorithm will process
	 * 
	 * @param frameSize
	 *   the maximum frame capacity that this algorithm is allowed to use
	 * 
 	 * @return
	 *   The number of page faults generated by this algorithm.
 	 */
	public int optimal(int[] referenceString, int frameSize) {

 		int faultCount = 0;
		int nextIndex = 0;
		int[] queue = new int[frameSize];
		
		// Fill the queue with sentinel values to indicate vacancies.
 		Arrays.fill(queue, -1);
 		
 		// Start by iterating over the page-reference string.
 		for (int i = 0; i < referenceString.length; i++) {

 			boolean matchFound = false;
			boolean vacant = false;
			int pageValue = referenceString[i];
			
			// Iterate over the queue to determine if the it already contains the value being proposed.
 			for (int k = 0; k < queue.length; k++) {

 				int queueValue = queue[k];

 				matchFound = false;
				vacant = false;
				
				// Check for matching values.
 				if (queueValue == pageValue) {

 					matchFound = true;
					break;
				}
 				
 				// Check if there are any vacancies from initialization.
 				if (queueValue == -1) {

 					vacant = true;
				}
			}
 			
 			// Next, we need to check if there are any vacancies in the data structure.  If so, this
 			// code will add the page into the queue at the appropriate index and then advance that
 			// index in a way that maintains the properties of a circularbuffer.
 			if (vacant) {

 				queue[nextIndex] = referenceString[i];
				nextIndex = Math.floorMod((nextIndex + 1), queue.length);
				faultCount++;
				continue;
			}
 			
 			// Enter this conditional if there is no matching pair found and if there exists no more vacancies.
 			if (!matchFound && !vacant) {
 				
 				int maxDistance = -1;
				int targetIndex = -1;
				
				// Iterate through whatever values are currently in the page frames queue in order
				// to compare them with the values in the page-reference string.
 				for (int queueIndex = 0; queueIndex < queue.length; queueIndex++) {
 					
 					int qValue = queue[queueIndex];
					int size = referenceString.length;
					
					// The variable 'threshold' is used as a decrementing index value representing a
					// difference between the size of the page-reference string list's elements and
					// where we currently are at this point in the main outer loop (i).
					int threshold = size - i;
					
					// Begin traversing the remainder of the page-reference string beginning at the
					// indexed element just after where we currently are (i + 1). This will help to
					// find pages that will be referenced again in the future.
 					for (int offsetIndex = i + 1; offsetIndex < size; offsetIndex++) {

 						int nextRefVal = referenceString[offsetIndex];
 						
 						// If we find a value in the remainder of the page-reference string that
 						// matches an element in our queue...
 						if (qValue == nextRefVal) {
 							
 							// Determine what is larger - the previously initialized or set maxDistance
 							// or the distance to the next matching value in the page-reference string.
 							if (offsetIndex - i > maxDistance) {
 								
 								maxDistance = offsetIndex - i;  // set a new max distance value
								targetIndex = queueIndex;       // maintain a reference to the insertion index
								break;
							}

 							else {
 								
 								// Although we did find a matching value, the offset index (difference) to that
 								// element is not larger than a previously-set value. We break here because we
 								// are no longer interested in considering this page-reference value.
 								break;
							}
						}
 						
 						// Here, threshold is decremented until it is equal to 1. When this happens, it
 						// means that the inner iteration could not find a matching value between the
 						// queue and the remaining page-reference strings. So, 
 						else if (--threshold == 1) {

 							maxDistance = referenceString.length;
							targetIndex = queueIndex;
						}
					}
				}
 				
 				// If no matching element could be found, add the page into the queue at the appropriate index
 				// and then advance that index in a way that maintains the properties of a circular buffer.
 				if (targetIndex == -1) {

 					queue[nextIndex] = referenceString[i];
					nextIndex = Math.floorMod((nextIndex + 1), queue.length);
				}
 				
 				// Otherwise, replace whatever page is in targetIndex with the value (i) we happen to be on.
 				else {

 					queue[targetIndex] = referenceString[i];
				}
 				
 				// In any case, some work to update a page has been done inside this conditional.
 				// Therefore, we increment a page fault.
 				faultCount++;
			}
		}
 		
 		return faultCount;
	}

 	/************************************************************************************************************
	 * Method to write the program results to a file on local storage.
	 * <p>
	 * 
	 * @postcondition
	 *   The results of the paging algorithm operations.
	 * 
	 * @throws IOException
	 *   IOException is thrown if there is an I/O problem with the results file output.
	 */
	public void writeToFile() throws IOException {

 		// File printing and output setup.
		File file = new File(OUTPUT_FILENAME);
		FileWriter fileWriter = new FileWriter(file, true);
		PrintWriter printWriter = null;

 		try {

 			if (!file.exists()) {

 				file.createNewFile();
			}

 			printWriter = new PrintWriter(fileWriter);

 			// Print the contents of the results to the output file.
			printWriter.println(stringBuilder.toString());
		}

 		catch (IOException ex) {

 			ex.printStackTrace();
		}

 		finally {

 			printWriter.close();
		}
	}
	
	/************************************************************************************************************
	 * Main method from where program execution begins.
	 * <p>
	 * 
	 * @param args
	 *   this parameter is not used
	 * 
	 * @postcondition
	 *   The following three page-replacement algorithms have operated on three distinct sets of page-reference
	 *   strings, and the results have been output to a text file on local storage:
	 * <p>
	 * 
	 * <CODE>First-In-First-Out (FIFO)</CODE></br>
	 * <CODE>Least-Recently-Used (LRU)</CODE></br>
	 * <CODE>Optimal (OPT)</CODE></br>
	 * 
	 * @throws InterruptedException
	 *   InterruptedException is thrown if a thread is interrupted before or during its activity.
	 * 
	 * @throws IOException
	 *   IOException is thrown if there is an I/O problem with the results file output.
	 */
 	public static void main(String[] args) throws InterruptedException, IOException {

 		PagingAlgorithms application = new PagingAlgorithms();

 		// Create an array of page-reference string arrays.
 		int[][] pageReferenceList = { randomPageReference, secondPageReference, thirdPageReference };
 		
 		// Iterate over the list of page-reference string arrays for processing.
 		for (int i = 0; i < pageReferenceList.length; i++) {
 			
 			// Process each page-reference string from 1 page frame up to 7 page frames.
 			for (int pageFrames = 1; pageFrames <= 7; pageFrames++) {
 				
 				int fifoFaults;
				int lruFaults;
				int optimalFaults;
				
				int[] currentReferenceString = pageReferenceList[i];

 				fifoFaults = application.firstInFirstOut(currentReferenceString, pageFrames);
 				lruFaults =application.leastRecentlyUsed(currentReferenceString, pageFrames);
				optimalFaults = application.optimal(currentReferenceString, pageFrames);
				
				stringBuilder.append("For " + pageFrames + " page frames, and using string page reference string: " + Arrays.toString(currentReferenceString) + "\r\n");
				stringBuilder.append("\r\n");
				stringBuilder.append("    FIFO had " + fifoFaults + " page faults.\r\n");
				stringBuilder.append("     LRU had " + lruFaults + " page faults.\r\n");
				stringBuilder.append("     OPT had " + optimalFaults + " page faults.\r\n");
				stringBuilder.append("\r\n");
			}
 			
 			stringBuilder.append("========================================================================================================================\r\n");
		}
 		
 		application.writeToFile();
	}
}
